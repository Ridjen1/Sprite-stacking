import pygame as pg


def import_images(path, num, scale):
	""" Функция для импорта картинок.

	Картинки должны быть названы как 0.png, 1.png, ...., и т.д.

	Аргументы:
	----------
	path : str
		Путь до папки с изображениями.
	num : int 	
		Число изображений.
	scale : int
	 	Масштабирующий коэффициент, т.е. во сколько раз увеличить картинки.


	Возвращаемое значение:
	----------
	images : list
		Список, содержащий увеличенные, если scale > 1, изображения.
	"""
	images = []
	for i in range(num):
		# Формируем название файла
		name = str(i)+'.png'
		# Загружаем изображение
		image = pg.image.load(path+name)
		# Масштабируем его
		image = pg.transform.scale(image, [image.get_width()*scale, image.get_height()*scale])
		# Добавляем полученное изображение в конец списка
		images.append(image)
	return images


class Object3D:
	""" Класс для 'трехмерных' объектов.

	Аргументы:
	----------
	x : int
		Позиция объекта на оси X (в пикселях).
	y : int
		Позиция объекта на оси Y (в пикселях).
	path : str
		Путь до папки с изображениями.
	num : int
		Число изображений (слоев).
	screen : pygame.Surface
			Экран игры, на котором будем отображать наш объект.
	scale : int
		Масштабирующий коэффициент, т.е. во сколько раз увеличить картинки и
		на сколько пикселей смещать слои относительно друг друга.


	Атрибуты:
	----------
	pos : list
		[x, y] - положение объекта на экране.
	path : str
		Путь до папки с изображениями.
	num : int
		Число изображений (слоев).
	screen : pygame.Surface
			Экран игры, на котором будем отображать наш объект.
	scale : int
		Масштабирующий коэффициент, т.е. во сколько раз увеличить картинки и
		на сколько пикселей смещать слои относительно друг друга.
	images : list
		Изображения (pygame.Surface) слоев для данного объекта.
	angle : int
		Угол поворота объекта.
	rotation_speed: int
		Скорость поворота объекта.
	turn_clockwise : bool
		Если значение True, объект поворачивается по часовой стрелке.
	turn_conterclockwise : bool
		Eсли значение True, объект поворачивается против часовой стрелки.
	"""
	def __init__(self, x, y, path, num, screen, scale=5):
		self.pos = [x, y]			
		self.path = path			
		self.num = num
		self.screen = screen			
		self.scale = scale			
		self.images = import_images(path, num, scale)
		# Переменные для вращения объекта
		self.angle = 0				
		self.rotation_speed = 2
		self.turn_clockwise = False
		self.turn_counterclockwise = False
		

	def blit_me_3d(self):
		""" Метод для отображения объекта с иллюзией 3D с использованием Sprite Stacking.


		Sprite Stacking:
		----------
		Этот метод создания иллюзии объема заключается в том, что мы послойно рисуем некоторый объект.
		После чего каждый следующий слой выводим на экран с определенным смещением по оси Y относительно
		предыдущего.
		При использовании этого метода мы поворачиваем и выводим на экран множество изображений для каждого объекта, 
		для которого хотим создать иллюзию объемности. Это относительно медленный процесс.
		А в игре может быть очень много объектов! Поэтому Sprite Stacking подойдет для маленьких проектов и игр, 
		где количество 3D объектов невелико.
		
		"""
		for i in range(self.num):
			# Поворачиваем исходный спрайт
			rotated_image = pg.transform.rotate(self.images[i], self.angle)
			# Выводим полученный спрайт на экране. Центрируем его, т.е. координаты объекта из self.pos
			# будут соответствовать центру спрайта. Для вычисления полуширины и полувысоты спрайта используем
			# // - деление нацело, т.к. пиксели дискретны и неделимы.
			# Для разных углов поворота полуширина и полувысота у одного и того же изображения
			# будут разными! (т.к. все послойные изображения имеют одинаковый размер, - для танка это 13 х 9 пикселей -
			# можно вынести вычисление полуширины и полувысоты перед циклом for)
			self.screen.blit(rotated_image, (self.pos[0]-rotated_image.get_width()//2, 
				self.pos[1]-rotated_image.get_height()//2-(i*self.scale)))

	def rotate_me(self):
		""" Метод для вращения объекта.

		В зависимости от значений логических переменных
		поворачиваем объект по часовой стрелке или против неё.

		Если угол больше 360 градусов, то вычитаем из значения угла 360.
		Eсли угол меньше 0, то прибавляем к значению угла 360.
		Всё это сохраняет значение угла в пределах от 0 до 360, если rotation_speed < 360.
		"""
		if self.turn_clockwise == True:
			self.angle -= self.rotation_speed
		elif self.turn_counterclockwise == True:
			self.angle += self.rotation_speed
		# Корректируем значение угла.
		if self.angle >= 360:
			self.angle -= 360
		elif self.angle < 0:
			self.angle += 360
